{"version":3,"sources":["src/preprocessAst/hoistNestedTypedefs.js"],"names":[],"mappings":";;;;;;;;;;qBAYS,mBAAmB;;kBAZb,IAAI;;;;2BACA,cAAc;;;;sBACd,QAAQ;;;;;;;;AAU3B,SAAS,mBAAmB,CAAC,QAAuB,EAAiB;AACjE,WAAO,QAAQ,CAAC,SAAS,CAAC,UAAA,IAAI,EAAI;AAC9B,YAAI,EAAE,SAAS,IAAI,IAAI,CAAA,AAAC,EACpB,OAAO,gBAAG,UAAU,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;;AAElC,YAAI,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,UAAA,IAAI;mBAAI,IAAI,CAAC,IAAI,KAAK,SAAS;SAAA,CAAC,CAAC;AACpE,YAAI,QAAQ,CAAC,MAAM,EACf,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,UAAA,IAAI;mBAAI,IAAI,CAAC,IAAI,KAAK,SAAS;SAAA,CAAC,CAAC;AACxE,eAAO,gBAAG,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,gBAAG,UAAU,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;KACtE,CAAC,CAAC;CACN","file":"src/preprocessAst/hoistNestedTypedefs.js","sourcesContent":["import Rx from 'rx';\r\nimport unique from 'array-unique';\r\nimport assert from 'assert';\r\n\r\n/// hoistNestedTypedefs extracts all `typedef`s which are interface members, and\r\n/// moves them before their containing interfaces.\r\n/// The resulting sequence contains no nested typedefs.\r\nexport\r\ndefault\r\n\r\nfunction hoistNestedTypedefs(astRoots: Rx.Observable): Rx.Observable {\r\n    return astRoots.concatMap(root => {\r\n        if (!('members' in root))\r\n            return Rx.Observable.of(root);\r\n\r\n        var typedefs = root.members.filter(node => node.type === 'typedef');\r\n        if (typedefs.length)\r\n            root.members = root.members.filter(node => node.type !== 'typedef');\r\n        return Rx.Observable.from(typedefs).concat(Rx.Observable.of(root));\r\n    });\r\n}"]}