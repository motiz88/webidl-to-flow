{"version":3,"sources":["src/preprocessAst/propagateImplements.js"],"names":[],"mappings":";;;;;;;;;;qBAUS,mBAAmB;;kBAVb,IAAI;;;;0BACI,cAAc;;;;;;;AASrC,SAAS,mBAAmB,CAAC,QAAuB,EAAiB;AACjE,WAAO,QAAQ,CAAC,OAAO,EAAE,CAAC,SAAS,CAAC,UAAA,KAAK,EAAI;AACzC,YAAI,GAAG,GAAG,6BAAW,KAAK,CAAC,MAAM,CAAC,UAAA,IAAI;mBAAI,IAAI,CAAC,IAAI,KAAK,YAAY;SAAA,CAAC,EACjE,QAAQ,EAAE,YAAY,EAAE,uBAAuB,CAAC,CAAC;;AAErD,YAAI,SAAS,GAAG,KAAK,CAAC,MAAM,CAAC,UAAA,IAAI;mBAAI,IAAI,CAAC,IAAI,KAAK,YAAY;SAAA,CAAC,CAAC;AACjE,YAAI,YAAY,GAAG,EAAE,CAAC;;AAEtB,YAAI,QAAQ,GAAG,SAAX,QAAQ,CAAI,EAAE,EAAK;AACnB,gBAAI,EAAE,IAAI,YAAY,EAClB,OAAO,YAAY,CAAC,EAAE,CAAC,CAAC;AAC5B,gBAAI,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,UAAA,IAAI;uBAAI,IAAI,CAAC,IAAI,KAAK,EAAE;aAAA,CAAC,CAAC;AACrD,gBAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EACpB,MAAM,IAAI,KAAK,CAAC,+CAA+C,GAAG,EAAE,CAAC,CAAC;AAC1E,gBAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAClB,MAAM,IAAI,KAAK,CAAC,+CAA+C,GAAG,EAAE,GAAG,6BAA6B,CAAC,CAAC;;AAE1G,wBAAY,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;AAC9B,mBAAO,YAAY,CAAC,EAAE,CAAC,CAAC;SAC3B,CAAC;;AAEF,WAAG,CAAC,KAAK,CAAC,OAAO,CAAC,UAAA,EAAE,EAAI;AACpB,eAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,UAAA,aAAa,EAAI;AACnC,wBAAQ,CAAC,EAAE,CAAC,CAAC,OAAO,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,CAAC;aACvF,CAAC,CAAC;SACN,CAAC,CAAC;;AAEH,eAAO,gBAAG,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;KACxC,CAAC,CAAC;CACN","file":"src/preprocessAst/propagateImplements.js","sourcesContent":["import Rx from 'rx';\r\nimport extractDag from './extractDag';\r\n\r\n/// propagateImplements walks the graph of `implements` statements and copies members from parent to child.\r\n/// The resulting sequence contains no IdlImplements nodes.\r\nexport\r\ndefault\r\n\r\nfunction propagateImplements(astRoots: Rx.Observable): Rx.Observable {\r\n    return astRoots.toArray().concatMap(roots => {\r\n        var dag = extractDag(roots.filter(node => node.type === 'implements'),\r\n            'target', 'implements', 'implements statements');\r\n\r\n        var restNodes = roots.filter(node => node.type !== 'implements');\r\n        var restNodesMap = {};\r\n\r\n        var nodeById = (id) => {\r\n            if (id in restNodesMap)\r\n                return restNodesMap[id];\r\n            var matches = roots.filter(node => node.name === id);\r\n            if (matches.length === 0)\r\n                throw new Error('No definition seen for implemented interface ' + id);\r\n            if (matches.length > 1)\r\n                throw new Error('Ambiguous reference to implemented interface ' + id + '; multiple definitions seen');\r\n\r\n            restNodesMap[id] = matches[0];\r\n            return restNodesMap[id];\r\n        };\r\n\r\n        dag.order.forEach(id => {\r\n            dag.edges[id].forEach(implementedId => {\r\n                nodeById(id).members = nodeById(id).members.concat(nodeById(implementedId).members);\r\n            });\r\n        });\r\n\r\n        return Rx.Observable.from(restNodes);\r\n    });\r\n}"]}